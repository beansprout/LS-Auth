@ls-auth

[TOC]

# Lecture - Authentication

### Example of Not Authenticated:

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-18-53.png) @img

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-18-55.png) @img

### Create a route

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-08.png) @img
![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-10.png) @img

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-12.png) @img
### Verify it works

### Debugging...

Stack Trace

![stack trace](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-18-58.png) @img

### Create signup route
auth.js
![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/auth.js-add-user-authenticationCapture2017-05-12-19-03.png) @img
### Hashing Passwords
before:

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-07.png) @img

#### Bcrypt
### bcrypt module

Resources:
[How to Hash Passwords with bcrypt](https://www.abeautifulsite.net/hashing-passwords-with-nodejs-and-bcrypt)
[Similar - Another how to hash pw in bcrypt](http://codetheory.in/using-the-node-js-bcrypt-module-to-hash-and-safely-store-passwords/)

`install bcrypt-nodjs`

- Creates good hashes
- Awesome random salt generator
- Makes it unfeasable for people to try to crack passwords
- Use https to scramble it...
- then upon saving we run Bcrypt

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-12.png) @img

### Clear out collections

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-13.png) @img

#### After:

Now our password looks like...

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-14.png) @img

- ‘$’ breaks into sections
- 3rd section is the salt
- Bcrypt took salt, added to pw, and then hashed it

### Rainbow Tables

### Salt, Salt factor
Decoding What is happening... matching ... decrypting never actually happens...

![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-23.png) @img

### JWT Based Authentication
* never store plain-text passwords
* JWT
* token-based authentication
* stateless authentication
* JWT secret
  in exports:

###  JSON Token Based Authentication

# Token based authentication

With most every web company using an API, tokens are the best way to handle authentication for multiple users.

## Why tokens?

The main reasons for tokens are:

- Stateless and scalable servers
- Mobile application ready
- Pass authentication to other applications
- Extra security

## [The Problems with Server Based Authentication](https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication#toc-the-problems-with-server-based-authentication)

### **Sessions**:

Every time a user is authenticated, the server will need to create a record somewhere on our server. This is usually done in memory and when there are many users authenticating, the overhead on your server increases.

### **Scalability**:

Since sessions are stored in memory, this provides problems with scalability. As our cloud providers start replicating servers to handle application load, having vital information in session memory will limit our ability to scale.

### **CORS**:

- As we want to expand our application to let our data be used across multiple mobile devices, we have to worry about cross-origin resource sharing (CORS).

- When using AJAX calls to grab resources from another domain (mobile to our API server), we could run into problems with forbidden requests.

### **CSRF:**

- need protection against [cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) (CSRF).
- Users are susceptible to CSRF attacks since they can already be authenticated with say a banking site and this could be taken advantage of when visiting other sites.

With these problems, scalability being the main one, it made sense to try a different approach.

## Token Based Authentication is Stateless

- We are not storing any information about our user on the server or in a session.

- This concept alone takes care of many of the problems with having to store information on the server.

No session information means your application can scale and add more machines as necessary without worrying about where a user is logged in.

## Token Based Auth - General Implementation
Although this implementation can vary, the gist of it is as follows:

1. User Requests Access with Username / Password
2. Application validates credentials
3. Application provides a signed token to the client
4. Client stores that token and sends it along with every request
5. Server verifies token and responds with data

Every single request will require the token

#### This token should be sent in the HTTP header...

 so that we keep with the idea of stateless HTTP requests.

#### Set Server to Accept Requests from All Domains

We will also need to set our server to accept requests from all domains using `Access-Control-Allow-Origin: *`.

***Note: What's interesting about designating `*` in the ACAO header is that it does not allow requests to supply credentials like HTTP authentication, client-side SSL certificates, or cookies.Stateless authentication***

![Infographic of Token Based Authentication](https://cask.scotch.io/2014/11/tokens-new.png) @img



Bcrypt check.. send back token
token will be sent back in the header
If the token is valid, they can continue to access.

- pro - don’t need to manage sessions

### Verifying User Can Access a Route:

#### getTokenforUser
![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-31.png) @img
## Creating our JWT token

### Services/token.js
sub: subject
need unique identifier so we know what user
iat: initialized at time
config.secret is in the config
![image-alt](/Users/Christine/Documents/Nvalt images/LS-Authentication/Capture2017-05-12-19-34.png) @img

### config.js
```
module.exports = {
  secret: 'This can literally be any string you want',
};
```

## Passport
handles the processing of the jwts
allow or deny people access to differnet routes
### Passport - ways it can be used (strategies)
- different ways of doing authentication
  [passportjs.org](passportjs.org)

### Handling the jwt request
### services/passport.js - imports:
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-41.png) @img
Set up Functions
jwtOptions
jwtLogin = new JwtStrategy
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-45.png) @img
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-46.png) @img
### Pass passport authentication into users.js -  Sets up Users Route to be Protected
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-47.png) @img
Note: getUsers will not run if requireAuth fails
- successful authentication has to happen first before anything else.
- process killed if fail
### Headers Authenticated Example:
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-52.png) @img
## Setting up Login Route
### in auth - set up another strategy - requireSignIn function
-pass in before login
-if valid, then run login
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-55.png) @img
### LocalStrategy = passport-local
strategy - import into passport.js
localOptions
localLogin
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-19-57.png) @img
### methods.checkpassord on the userSchema
TODO screenshot ~8:03
### User.findOne
-aside email OR password is incorrect message
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-02.png) @img

![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-03.png) @img
Last thing:
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-04.png) @img
can do that because of require sign in middleware
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-04.png) @img
Can make a request and
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-06.png) @img
Can now plug in
![image-alt](/Users/Christine/Documents/Nvalt images/Capture2017-05-12-20-07.png) @img


![image-alt](/Users/Christine/Documents/Nvalt images/LS Video 7 2017-05-12 at 6.43.14 PM.png) @img



# LS-Auth Project 05.13.17# LS-Auth

## Packages

* `bcrypt-nodejs`
* `jwt-simple`
* `passport`
* `passport-jwt`
* `passport-local`



## Assignment

Clone down this project.  Run `npm i`.
Start your MongoDB server by running `mongod` from the command line.
Implement the following routes.
You will also need to create a `config.js` file that will house your `secret`.

* [POST] `/signup` This route should add a new user to the `users` collection.  After creating the user return a `JWT` token to the client.
* [POST] `/signin` This route will receive a `username` and `password` in the request body.  If the `username` and `password` combination are valid then return a `JWT` token.
* [GET] `/users` This route will return an array of all users.  Only return the users if the user provides a valid `JWT` token in the `authentication` header.
* [POST] `/blog-posts` This route should create a new blog post and add it to the `blogPosts` collection.  This route should only work if the user provides a valid `JWT` token.
* [GET] `/blog-posts` This route should return every `blogPost` in an array.  This route should only work if the user provides a valid `JWT` token.
